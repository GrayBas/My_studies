def tp(lst):
    tup = ()
    for string in lst:
        n, i, o, z = string.split(';')
        if n.isdigit() and o.isdigit:
            tup += ((i, z, int(o), int(n)),)
        else:
            tup += ((i, z, o, n),)
    return tup


lst_in = ['Номер;Имя;Оценка;Зачет', '1;Портос;5;Да', '2;Арамис;3;Да',
          '3;Атос;4;Да', "4;д'Артаньян;2;Нет", '5;Балакирев;1;Нет']
t = tp(lst_in)
t_sorted = ((t[0]),) + tuple(sorted(t[1:], key=lambda x: x[-1]))

print(t_sorted)
#___________________________________________________________________________________
haders = tuple('Имя;Зачет;Оценка;Номер'.split(';'))
t = tuple(tuple(int(e) if e.isdigit() else e for e in s.split(';')) for s in lst_in)
t_sorted = tuple(zip(*sorted(zip(*t), key=lambda x: haders.index(x[0]))))

''''Решил еще раз разобрать пошагово сам.
1) lambda x - кортежи танспонированной матрицы:

('Номер', 1, 2, 3, 4, 5), ('Имя', 'Портос', 'Арамис', 'Атос', "д'Артаньян", 'Балакирев'), ('Оценка', 5, 3, 4, 2, 1), ('Зачет', 'Да', 'Да', 'Да', 'Нет', 'Нет')
2) order - "Имя;Зачет;Оценка;Номер"

3) order.find() -  в строке order найти и вернуть индекс подстроки

4) order.find(x[0]) -  в строке order найти и вернуть индексы подстрок: 'Номер', 'Имя', 'Оценка', 'Зачет'.Так, что: "Номер" = 3, "Имя" = 0, "Оценка" = 2, "Зачет" = 1

5) key=lambda x: order.find(x[0])- сортировать кортежи из пункта 1) в соответствии с индексами первых элементов. Т.е. сначала кортеж с Именем (0), потом с Зачетом (1), затем с Оценкой (2) и Номером (3).'''