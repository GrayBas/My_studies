""" Одномерное динамическое программирование"""

""" Задача о кузнечике на числовой прямой"""
""" Кузнечик может прыгать на +1, +2 и +3 клеток, на некоторые клетки нельзя становиться.

        Дано число 'n' -> int - крайняя точка на числовой прямой куда нужно попасть
        массив allowed: list[bool] содержит на каждую точку числовой прямой 'n' значение
        True - можно становиться,False - запрещено становиться.
        0 - изпользуем как барьерный элемент.
        k - Список. в него внесли начальный эл-т 1 и барьерный 0. под индексом 2 внесли
            int(allowed[2]), т,к заранее не известно можноли становиться на эту точку или вести от нее отсчет

    Необходимо узнать количество всех возможных маршрутов до точки 'n'
        в цикле идем по индексам массива от 3 до 'n' включительно и если в массиве allowed под выбранным
        индексом стоит True то суммируем все возможные пути до точки k[i]. иначе осталяем 0.
"""

def traj_num(n: int, allowed: list):
    k = [0, 1, int(allowed[2])] +[0] * (n-3) 
    for i in range(3, n+1):
        if allowed[i]:
            k[i] = k[i-1] + k[i-2] + k[i-3]
    return sum(k)


""" Минимальная стоимость достижения клетки N """
""" двигаться можно лишь на +1 или +2 клетки
    Дано число 'n' -> int - крайняя точка на числовой прямой куда нужно попасть
    массив price, содержит стоимость для каждой клетки. price[i] - цена за посещение клетки 'i' 
    массив C содержит минимальную стоимость достижения для каждой клетки
    C[i] - минимальная стоимость достижения клетки 'i'. C[i] = price[i] + min(C[i-1], C[i-2])

    необходимо узнать минимальную стоимость достижения клетки 'N'
        создаём массив 'C' где в качестве барьерного э-та используем (-бесконечность), а на эл-т с которого начинаем
        забисываем мин стоимость price[1], для второго эта стоимость будет price[1]+price[2], так как иных вариантов
        стоимости тут нет.
        в цикле бежим по индексам соответствующим индексам массива 'C' и для каждой клетки смотрим на стоимость её
        соседей i-1 и i-2(т.к. возможные шаги передвижения +1 и +2) и выбираем того соседа стоимость которого меньше,
        и складываем её со стоимостью клетки 'i'
    По выходу из цикла в списке 'C' по индексом [N] будет содержаться мнимальнаю стоимость достижения клетки 'N'
"""

def count_min_coast(N, price: list):
    C = [float('-inf'), price[1], price[1]+price[2]] + [0] * (N-2)
    for i in range(3, N+1):
        C[i] = price[i] + min(C[i-1], C[i-2])

    return C[N]


